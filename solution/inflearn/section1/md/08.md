# [section1] 일곱 난쟁이
## 문제 요약 📚
- 아홉 난쟁이의 키는 모두 다름
- 일곱 난장이들의 키의 합은 100
- 일곱 난장이가 될 수 있는 경우의 수를 구해 일곱 난쟁이의 키 출력

## 소요 시간 ⌛️
- Time Over 😭 (첫번째 시도)
- 약 7분 (힌트본 뒤, 두번째 시도)

## 문제 풀이 📝
### 1. 코드리뷰 전의 코드
```
function solution(arr) {
  let answer = arr;
  let sum = arr.reduce((arr, cur) => arr + cur, 0);

  for(let i =0; i< arr.length; i++) {
    for (let j = i+1; j < arr.length; j++) {
      if ( sum - (arr[i] + arr[j]) === 100) {
        answer.splice(answer.indexOf(arr[i]), 2);
      }
    }
  }

  return answer;
}

let arr=[20, 7, 23, 19, 10, 15, 25, 8, 13];
console.log(solution(arr));
```
> **코드리뷰 후 알게된 문제점!** 첫번째 인덱스값에서 부터 두번째 갯수 만큼 제거 하는 메소드기 때문에 **두개의 10 과 25 값이 떨어져 있는 경우는 제대로 동작하지 않음**
- `reduce`를 이용해서 총 합계를 모두 구함
- 이중 반복문을 돌려서 합계에서 두 원소를 뺀 나머지가 100인 경우, 가짜 난쟁이!

### 2. 코드리뷰 후의 코드_ splice 수정
```
function solution(arr) {
  let answer = arr;
  let sum = arr.reduce((arr, cur) => arr + cur, 0);

  for(let i =0; i< arr.length; i++) {
    for (let j = i+1; j < arr.length; j++) {
      if ( sum - (arr[i] + arr[j]) === 100) {
        answer.splice(j, 1);
        answer.splice(i, 1);
      }
    }
  }

  return answer;
}

let arr=[20, 7, 23, 15, 19, 10, 25, 8, 13];
console.log(solution(arr));
```
- `i`를 먼저 제거할 경우, `i`는 `j`보다 앞에 있어 뒤의 요소 제거에 영향을 줌
- `j`먼저 제거

### 3. 코드리뷰 후의 코드_filter 사용
```
function solution2(arr) {
  let sum = arr.reduce((arr, cur) => arr + cur, 0);
  return arr.filter( item => !(arr.indexOf(sum - 100 - item) > 0));
}

let arr2=[20, 7, 2, 23, 19, 10, 38, 8, 13];
console.log(solution2(arr2));
```
  - 100에서 초과된 값 `40` - `item`을 하게 되면 `item의 짝`이 나오는 원리를 이용
  - `40 - 20`같이 뺀 값이 `item`과 동일한 경우, 조건에 난쟁이 키는 모두 다르다고 했기 때문에 해당 케이스는 `item` 본인을 가리키게 됨으로 해당 케이스는 제외
    ```
    arr.indexOf(sum - 100 - item) > 0
    ```
  - `filter`는 반환값이 `true`인 요소만 새로운 배열로 반환하여 생성하기 때문에 위의 반대 케이스를 `return`

## 실행속도 ⏱
```
s1: 약 0.04초
s2: 약 0.045초
```
- 실행 환경에 따라 다르겠지만 이 정도의 데이터로는 둘이 비슷하게 동작하는 것 같다..!
- 오히려 고차함수를 쓴 쪽이 느린 것 같기도... 🤔

## 문제에 대한 생각 🧐
- 알고리즘에서 이중 for문은 지양한다는 얘기를 듣고 최대한 이중 for문을 사용하지 않으려다 첫번째 시도때 못풀었다..
- 강사님의 말씀 중 `이중 for문`, `2개의 랜덤한 숫자`로 힌트를 얻고 재도전 해서 드디어 성공!
- 커뮤니티를 보니 `이중 for문`을 이용하지 않고도 푸는 사람들이 있다..
- `이중 for문` 없이 한번 더 풀어봐야겠다!

### **+) 코드리뷰 내용**
- `통붕이`님께서 기존 코드의 치명적인 오류에 대해 조언해주셨다!
   > `splice( )` 는 첫번째 인덱스값에서 부터 두번째 갯수 만큼 제거 하는 메소드기 때문에 두개의 10 과 25 값이 떨어져 있는 경우는 제대로 동작하지 않을 듯 합니다.

   - ㅠㅜ.. 완전 기본적이고 치명적인 오류였다.. 🤦‍♀️
   - 기존 코드도 수정해보고 `이중 for문` 없이 `filter`를 사용해서 다시 새롭게 풀어보았다!
   - 고차함수 사용이 좀 더 느린 것 같기도하고.. 정확한 속도 측정이 불가능해서 아쉽다!
   - 이 코드에 대해서는 멤버들의 피드백을 듣고싶다!

- - -
## 문제 답안 🗞
```
 저작권관련 이슈가 있을 수 있음으로 답안은 비공개처리 하였습니다.
```
- 9개의 숫자 중 2개를 뽑고 2개의 숫자가 가짜인지 확인하는 원리로 진행
- 이중 for문을 돌려서 일일이 확인
- `sum - (arr[i] + arr[j])` 뺐을 때 100이 되면 가짜 난쟁이
- `splice`로 제거 후 출력

- - -
위의 내용은 알고리즘을 공부하며 개인적으로 정리한 내용입니다.
## 출처 📝
- [인프런 - 자바스크립트 알고리즘 문제 풀이](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/dashboard)